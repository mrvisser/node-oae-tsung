/*
 * Copyright 2012 Sakai Foundation (SF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 * 
 *     http://www.osedu.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var fs = require('fs');
var readline = require('readline');
var tsung = require('./lib/tsung');
var util = require('util');
var wrench = require('wrench');
var TsungUtil = require('./lib/util');

var millis = new Date().getTime();

var optimist = require('optimist')
        .usage('Usage: $0 -o <output dir> -d <data format dir>')

        .alias('o', 'output-dir')
        .describe('o', 'The directory in which the output Tsung package should be generated.')
        .default('o', util.format('./tsung-%s', millis));
var argv = optimist.argv;

if (argv['help']) {
    return console.log(optimist.help());
}

var config = {
    'loglevel': 'notice',
    'version': '1.0',
    'dumpTraffic': false
};

var outputRoot = argv.o;

var suite = null;
var runner = new tsung.Tsung(config);

// Read from the commandline.
var rl = readline.createInterface({
  'input': process.stdin,
  'output': process.stdout
});

/**
 * Parses all the data format files from the specified data directory. There should be a number of files with extension
 * `.format` in this directory. On the first line, the format file specifies how a CSV file (of the same name) will be
 * interpretted by Tsung. The first line of the format file will specify a comma-separated list of variable names that
 * should match the columns of the CSV file. The second line defines how the file should be traversed (`iter` or `random`).
 * The filename will be used as an internal identifier. Make sure the variable names are globally unique across all your
 * data files.
 */
var generateDataConfiguration = function() {
    try {
        var dataConfig = require('./config/data.json');
    } catch (err) {
        // no data config. this is fine I guess.
        return;
    }
        
    // file servers
    if (dataConfig.files) {
        for (var id in dataConfig.files) {
            var file = dataConfig.files[id];
            runner.addFileServer(id, util.format('data/%s.csv', id), file.vars, ',', file.order);
        }
    }

    // randomized strings
    if (dataConfig.strings) {
        for (var id in dataConfig.strings) {
            runner.addRandomStringGenerator(id, dataConfig.strings[id].length);
        }
    }

    // randomized numbers
    if (dataConfig.numbers) {
        for (var id in dataConfig.numbers) {
            runner.addRandomNumberGenerator(id, dataConfig.numbers[id].start, dataConfig.numbers[id].end);
        }
    }
}

/**
 * Prompts the user for the test suite to run.
 *
 * @param {Function} callback Invoked when the user has set up the suite
 */
var promptSuite = function(callback) {
    rl.question("What suite would you like to run? ", function(answer) {
        suite = answer;
        callback();
    });
}

/**
 * Prompts the user for the tsung clients from which the performance test will be run.
 *
 * @param {Function} callback Invoked when the user has finished specifying their input
 */
var promptClient = function(callback) {
    rl.question("What clients are you driving your tests from? [hostname1,hostname2,...]? ", function(answer) {
        runner.addClient(answer, true, 10000);
        callback();
    });
}

/**
 * Prompts the user for the servers that will be tested by tsung.
 *
 * @param {Function} callback Invoked when the user has finished specifying their input
 */
var promptServer = function(callback) {
    rl.question("What server are you running this test against? [hostname:port] ", function(answer) {
        var server = answer.split(':');
        if (server.length !== 2 || !parseInt(server[1], 10)) {
            console.log('Please provide a valid server.');
            promptServer();
        } else {
            runner.addServer(server[0], server[1]);
            rl.question('Add another server? [y/N] ', function(answer) {
                if (answer === 'y') {
                    promptServer(callback);
                } else {
                    callback();
                }
            });
        }
    });
};

/**
 * Prompts the user for the test phases that should generated by tsung.
 *
 * @param {Function}    callback    Invoked when the user has finished specifying their input
 * @param {Number}      i           The index of the current phase. If starting anew, don't specify this parameter
 */
var promptPhases = function(callback, i) {
    i = i || 1;
    rl.question('Phase ' + i + ': In what unit should the phase time be measured? [hour, minute, second] ', function(answer) {
        if (answer === 'hour' || answer === 'minute' || answer === 'second') {
            var phaseUnit = answer;
            rl.question('Phase ' + i + ': How long should the phase take (in ' + phaseUnit +'s) ? ', function(answer) {
                var time = parseInt(answer, 10);
                if (time > 0) {
                    rl.question('Phase ' + i + ': In what unit should users be added [hour, minute, second] ? ', function(answer) {
                        if (answer === 'hour' || answer === 'minute' || answer === 'second') {
                            var usersUnit = answer;
                            rl.question('Phase ' + i + ': How many users should be added per ' + usersUnit + ' ? ', function(answer) {
                                var newUsers = parseInt(answer, 10);
                                if (newUsers > 0) {
                                    runner.addPhase(time, phaseUnit, newUsers, usersUnit);
                                    rl.question('Add another phase? [y/N]', function(answer) {
                                        if (answer === 'y') {
                                            promptPhases(callback, i+1);
                                        } else {
                                            callback();
                                        }
                                    });
                                } else {
                                    console.log('Invalid amount');
                                    promptPhases(callback, i);
                                }
                            });
                        } else {
                            console.log('Invalid timeunit');
                            promptPhases(callback, i);
                        }
                    });
                } else {
                    console.log('Invalid amount');
                    promptPhases(callback, i);
                }
            });
        } else {
            console.log('Invalid timeunit');
            promptPhases(callback, i);
        }
    });
};

var packageTestRunner = function(xml, callback) {
    wrench.mkdirSyncRecursive(outputRoot, 0777);
    fs.writeFile(util.format('%s/tsung.xml', outputRoot), xml, 'utf-8', callback);
}

var printErr = function(err, msg) {
    console.log(msg);
    console.log(err);
    console.log(err.stack);
}

// first parse and build the data model
generateDataConfiguration();

// then gather user information
promptSuite(function() {
    TsungUtil.generateTestsForSuite(runner, suite, function(err) {
        if (err) {
            return printErr('Error generating tests for suite.');
        }
        promptClient(function() {
            promptServer(function() {
                promptPhases(function() {
                    rl.close();
                    runner.toXml(function(xml) {
                        packageTestRunner(xml, function(err) {
                            if (err) {
                                return printErr('Error packaging up the test runner.', err);
                            }
                            console.log('Test successfully generated in %s', outputRoot);
                        });
                    });
                });
            });
        });
    });
});
